#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path);
use Getopt::Long;
use Term::ANSIColor;

# Default values {{{
my $help              = 0;
my $detach            = 0;
my $run               = "";
my $save              = "";
my $headless          = 0;
my $ssh               = "7100";
my $create            = "";
my $port_vnc          = "3";
my @volume            = ();
my $bridge_interface  = "br0";
my $ram               = "4096";
my $core              = "4";
my $cpu               = "";
my $machine           = "";  # host
my $machine_name      = "virtual-machine";
my $machine_desc      = "QEMU/KVM virtual machine";
# my $sharedfolder_path = $ENV{PWD};
my $image_format      = "";  # Optional: e.g., qcow2, raw
my $script_name       = basename($0);
my $script_path       = dirname($0) . "/";
my @iso_path          = ();
my @image_path        = ();
my @port_forward      = ();
# }}}

# printer {{{
sub printer {
    my $kind = $_[0];
    my $message = $_[1];

    print("[${script_name}::$kind] $message");
}
# }}}

# argument parser {{{
GetOptions(
    "help"         => \$help,
    "headless"     => \$headless,
    "detach"       => \$detach,
    "save"         => \$save,
    "display=s"    => \$port_vnc,
    "create=s"     => \$create,
    "ssh=s"        => \$ssh,
    "ram=s"        => \$ram,
    "core=s"       => \$core,
    "cpu=s"        => \$cpu,
    "machine=s"    => \$machine,
    "name=s"       => \$machine_name,
    "desc=s"       => \$machine_desc,
    "run=s"        => \$run,
    "interface=s"  => \$bridge_interface,
    # "share=s"      => \$sharedfolder_path,
    "format=s"     => \$image_format,
    "volume=s@"    => \@volume,
    "port=s@"      => \@port_forward,
    "image=s@"     => \@image_path,
    "iso=s@"       => \@iso_path,
) or die "Invalid options. Use --help for usage info.\n";
# }}}

# print help and exit {{{
sub print_help {
    my $message = "Usage: $script_name [options]\n".
                  "\n".
                  "Options:\n".
                  "    --create     NAME,SIZE   Create new image            <NAME>,<SIZE>\n".
                  "    --run        FILE        Run the existing vm config  \n".
                  "    --image      FILE        Path to the disk image      .img\n".
                  "    --iso        FILE        Path to ISO file            for installation\n".
                  "    --ssh        PORT        SSH port to forward         default: ${ssh}\n".
                  "    --port       SRC:DST     port forward                comma separated: e.g. 8088:80,9090:6304,9099:21\n".
                  "    --core       NUM         How many core pass to vm    default: ${core}\n".
                  "    --ram        MB          How much ram pass to vm     default: ${ram}\n".
                  "    --display    NUM         VNC display port            default: ${port_vnc}\n".
                  "    --volume     PATH:TAG    Tag used for VirtFS mount   default: none\n".
                  "    --interface  NAME        Network bridge interface    default: ${bridge_interface}\n".
                  # "    --share      DIR         Shared folder path          default: '${sharedfolder_path}'\n".
                  "    --format     TYPE        Image format                e.g. qcow2, raw -- Optional\n".
                  "    --name       NAME        Machine's name              e.g. 'work-machine-debian'\n".
                  "    --desc       DESC        More info about machine     e.g. 'New library -- test env'\n".
                  "    --headless               Run in headless mode        omit VNC\n".
                  "    --detach                 Detach the child process\n".
                  "    --save                   Create config file          don't run the vm  (DEPRECATED)\n".
                  "    -h, --help               Show this help message\n";
    print($message);
    exit 0;
}
# }}}

# create image {{{
sub create_image {

    print("Enter image name (no ext): ");
    my $name = <STDIN>;
    chomp($name);
    $name = $name.'.img' unless $name =~ /\.img$/;
    $name =~ s/ /-/g;

    print("Enter image size (in GB):  ");
    my $size = <STDIN>;
    chomp($size);
    my $format = 'qcow2';

    my @cmd = (
        "qemu-img", "create", "-f", $format, $name, $size,
    );
    unless (-f $name) {
        exec(@cmd);
    } else {
        warn("$script_name: qemu-img: Image exists");
        warn(`du $name`);
        die("\n");
    }
}
# }}}

print_help() if $help;

# create child process {{{
if ($detach) {
    my $pid = fork();
    exit(1) if $pid < 0;
    exit(0) if $pid > 0;
}
# }}}

# generate list {{{
sub multiple_image {
    my @name = @_;
    my $files = join ",", @name;
    return $files;
}

sub multiple_volume {
    my @input = @_;
    my @args = ();  # default ssh port
    for my $vol (@input) {
        my @splitted = split(":", $vol);
        my $volume_path = $splitted[0];
        my $volume_tag  = $splitted[1];
        push @args, ("-virtfs", "local,path=$volume_path,mount_tag=$volume_tag,security_model=mapped,id=$volume_tag");
    }
    return @args;
}

sub multiple_port_forwart {
    my @input = @_;
    my $args = "user,hostfwd=tcp::${ssh}-:22";  # default ssh port
    for my $pf (@input) {
        my @splitted = split(":", $pf);
        my $port_host = $splitted[0];
        my $port_guest = $splitted[1];
        $args .= ",hostfwd=tcp::${port_host}-:${port_guest}" if $args;
    }
    return $args;
}
# }}}

if ($create) {
    create_image($create);
}

# extra stuff {{{
my $image_name = "";

# manage vnc port
$port_vnc =~ s/:// if $port_vnc;

# if ($sharedfolder_path) {
#     make_path($sharedfolder_path) unless -d $sharedfolder_path;
# }

# view running mode
my $mode = "Live" unless $port_vnc;
$mode ||= "Normal";
# }}}

# environment {{{
# write {{{
sub env_write {
    # config file name -- generate
    my $subname = (split(":", (caller(0))[3]))[-1];
    my $config_filename = "$script_name-$machine_name.yml";
    $mode = "Headless" if $headless;

    my @unsorted_data = (
        { key => 'image.format', value => $image_format },
        { key => 'machine.core', value => $core },
        { key => 'machine.cpu', value => $cpu },
        { key => 'machine.desc', value => $machine_desc },
        { key => 'machine.machine', value => $machine },  # WIP
        { key => 'machine.name', value => $machine_name },
        { key => 'machine.ram', value => $ram },
        { key => 'net.interface', value => $bridge_interface },
        { key => 'port.ssh', value => $ssh },
        { key => 'port.vnc', value => $port_vnc },
        { key => 'script.name', value => $script_name },
        { key => 'script.path', value => $script_path },
    );
    foreach my $img (@image_path) { push(@unsorted_data, { key => 'image.path', value => $img }); }
    foreach my $port (@port_forward) { push(@unsorted_data, { key => 'port.bind', value => $port }); }
    foreach my $vol (@volume) { push(@unsorted_data, { key => 'volume.path', value => $vol }); }
    my @data = sort @unsorted_data;

    my $max_length = 0;
    foreach my $entry (@data) {
        my $len = length($entry->{key});
        $max_length = $len if $len > $max_length;
    }

    my @unorder_config = ();
    foreach my $entry (@data) {
        my $current_length = length($entry->{key});
        my $padding = $max_length - $current_length + 1;  # Correct variable to calculate padding
        push @unorder_config, sprintf "\r%s%s: '%s'\n", $entry->{key}, " " x $padding, $entry->{value};  # Adding padding here
    }
    my @config = sort @unorder_config;
    print "\r# ====================================================\n";
    print "\r# QEMU Virtual Machine is running in $mode mode\n";
    print "\r# ====================================================\n";
    # print "\r# \n";
    print "@config\n";

    # my @images = split ",", multiple_image(@image_path);
    # foreach my $image (@images) {
    #     push @config
    # }

    # my $config_double_check = "n";
    # if (-e $config_filename) {
    #     printer($subname, "config file exists, would you like to overwrite it? [y/N] ");
    #     $config_double_check = <STDIN>;
    #     chomp($config_double_check);
    # } else {
    #     $config_double_check = "Y";
    # }
    #
    # if ($config_double_check =~ /[yY]/) {
    #     open(FH, '>', $config_filename) or die $!;
    #     print(FH @config);
    #     close(FH);
    #     printer($subname, "config file generated\n");
    # } else {
    #     printer($subname, "not even touched\n");
    # }

}
# }}}
# read {{{
sub env_read {
    my ($key, $file) = @_;
    $file //= $run;

    unless ($key) {
        print(STDERR "The key pattern must be specified\n");
        exit 1;
    }

    open(my $fh, '<', $file) or die "Could not open file '$file' $!";
    my $anymatch = 0;
    my $anyline = 0;
    my $match = '';
    while (my $line = <$fh>) {
        chomp($line);
        my ($k, $value) = split(/:/, $line, 2);
        if ($k =~ /$key/) {
            # $value =~  s/^\s+//;  # trim
            # $value =~  s/\s+$//;  # trim
            $value =~ s/^\s+|\s+$//g;  # trim
            $value =~ s/^"//g;  # remove ' and "
            $value =~ s/"$//g;  # remove ' and "
            $value =~ s/^'//g;  # remove ' and "
            $value =~ s/'$//g;  # remove ' and "
            if ($k =~ /pass/) {
                $match = decode_base64($value);
            } else {
                $match = $value;
            }
            print("[$key]: $value\n");
        } else {
            $anymatch++;
        }
        $anyline++;
    }
    close($fh);
    if ($anyline == $anymatch) {
        print(STDERR color("bold red")."error".color("reset")." [loadenv] no matching pattern: $key\n");
    }
    return $match;
}
# }}}
# }}}

# Launch QEMU {{{
sub vmlauncher {
    my $qemu = `which qemu-system-x86_64`;  # TODO: different archs
    my @_name = split("/", $qemu);
    my $name = $_name[-1];
    my @images = @image_path;
    chomp($qemu);
    chomp($name);

    if ($qemu) {
        env_write();

        if ($run) {

            @images              = split ",", env_read("image.path");
            $machine_name        = env_read("machine.name");
            $core                = env_read("machine.core");
            $ram                 = env_read("machine.ram");
            $machine_desc        = env_read("machine.desc");
            $image_name          = env_read("image.name");
            $image_format        = env_read("image.format");
            # $iso_path            = env_read("iso.path");
            $script_name         = env_read("script.name");
            $script_path         = env_read("script.path");
            $ssh                 = env_read("port.ssh");
            $port_vnc            = env_read("port.vnc");
            # $port_forward        = env_read("port.forward");
            # $sharedfolder_path   = env_read("share.path");
            # $volume             = env_read("share.tag");
            $bridge_interface    = env_read("net.interface");

            # exit 0;

        }

        # exec command
        my @cmd = (
            $qemu,
            "-boot", "order=d",
        );
        if ($images[0]) {
            foreach my $image (@images) {
                my $drive_arg = "file=$image";
                $drive_arg .= ",format=$image_format" if $image_format;
                push @cmd, "-drive", $drive_arg;
            }
        }
        push @cmd,
            "-m", $ram,
            "-smp", $core,
            "-enable-kvm",
            "-net", "nic,model=virtio",
        ;

            # "-virtfs", "local,path=$sharedfolder_path,mount_tag=${volume},security_model=mapped,id=${volume}",
        push @cmd, multiple_volume(@volume);
        push @cmd, "-net", multiple_port_forwart(@port_forward);
        push @cmd, "-vnc", ":${port_vnc}" if $headless;

        # if (@port_forward) {
        #     # my @_pfs = split(",", $port_forward);
        #     for my $_pf (@port_forward) {
        #         my @_ps = split(":", $_pf);
        #         my $port_host = $_ps[0];
        #         my $port_guest = $_ps[1];
        #         $pfargs .= ",hostfwd=tcp::${port_host}-:${port_guest}" if $pfargs;
        #     }
        #     push @cmd, "-net", $pfargs if $pfargs;
        # }

        if ($iso_path[0]) {
            foreach my $iso (@iso_path) {
                push @cmd, "-cdrom", "${iso}";
            }
        }
        # push @cmd, "-vnc", ":${port_vnc}" if $headless;
        push @cmd, "-cpu", $cpu if $cpu;
        push @cmd, "-machine", $machine if $machine;
        # print "@cmd\n";
        exec @cmd;

    }
    die "$script_name: $name: command not found\n";
}
# }}}

vmlauncher();

